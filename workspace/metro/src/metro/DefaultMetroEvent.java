/*
 * Metro Musical Sequencing Framework written by Atsushi Oka 
 * Copyright 2018 Atsushi Oka
 *
 * This file is part of Metro Musical Sequencing Framework. 
 * 
 * Metro Musical Sequencing Framework is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * Metro Musical Sequencing Framework is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with Metro Musical Sequencing Framework.  If not, see <https://www.gnu.org/licenses/>.
 */

package metro;

/**
 * TODO this comment needs to be updated. 
 * 
 * This interface provides common methods for objects that represents every
 * notes in a bar. Bars are usually generated by the tracks. This interface is
 * strongly related to {@link MetroTrack#progressCursor(int, List) } method;
 * refer the {@linkplain MetroTrack#progressCursor(int, List) method} for
 * further information.
 * <p>
 * These methods are called as a callback of JACKAudio processing; these method
 * should return as soon as possible. The heavy processing that blocks for
 * longer time than the current setting of JACK's frame rate causes JACK to
 * XRUN.
 * 
 * @author Ats Oka
 */

/**
 * This class is the base class to manage all events that are sent/received between Metro framework and its client.
 * @author Ats Oka
 */
public abstract class DefaultMetroEvent implements MetroEvent {
    private String id;
    public DefaultMetroEvent( String id, double barOffset ) {
        super();
        this.id = id == null ? super.toString() : id;
        this.barOffset = barOffset;
    }

    private double barOffset;
    @Override
    public final double getBarOffset() {
        return barOffset;
    }
    @Override
    public void setBarOffset(double barOffset) {
        this.barOffset = barOffset;
    }
    @Override
    public final boolean isBetween( double from, double to) {
        return from <= this.barOffset && this.barOffset < to;
    }
    
    private int barOffsetInFrames;
    @Override
    public final int getBarOffsetInFrames() {
        return barOffsetInFrames;
    }
    @Override
    public final void calcBarOffsetInFrames( int barLengthInFrames ){
        this.barOffsetInFrames = (int)(this.barOffset * barLengthInFrames );
    }
    @Override
    public boolean isBetweenInFrames( int from, int to ) {
        return from <= this.barOffsetInFrames && this.barOffsetInFrames < to;
    }
    
    @Override
    public final String dump(String prefix) {
        StringBuilder sb = new StringBuilder();
        dumpProc(prefix, sb);
        return sb.toString();
    }
    public void dumpProc( String prefix, StringBuilder sb ) {
        sb.append(prefix).append( "                id: " + id                ).append( "\n" );
        sb.append(prefix).append( "            offset: " + barOffset         ).append( "\n" );
        sb.append(prefix).append( "    offsetInFrames: " + barOffsetInFrames ).append( "\n" );
    }
    
    @Override
        public String toString() {
            return "(MidiEvent " + id + ")";
        }

//  public static void main(String[] args) {
//      MetroMidiEvent event = new MetroMidiEvent(1, 0.0d, new byte[] {} );
//      event.calcInFrames(48000);
//      boolean b = event.between(-1, 4);
//      System.out.println( b );
//  }

}
